diff --git a/abspath.c b/abspath.c
index 40cdc46..85c824a 100644
--- a/abspath.c
+++ b/abspath.c
@@ -21,7 +21,7 @@ int is_directory(const char *path)
  * absolute_path().)  The return value is a pointer to a static
  * buffer.
  *
- * The input and all intermediate paths must be shorter than MAX_PATH.
+ * The input and all intermediate paths must be shorter than GIT_MAX_PATH.
  * The directory part of path (i.e., everything up to the last
  * dir_sep) must denote a valid, existing directory, but the last
  * component need not exist.  If die_on_error is set, then die with an
@@ -33,7 +33,7 @@ int is_directory(const char *path)
  */
 static const char *real_path_internal(const char *path, int die_on_error)
 {
-	static char bufs[2][PATH_MAX + 1], *buf = bufs[0], *next_buf = bufs[1];
+	static char bufs[2][GIT_MAX_PATH + 1], *buf = bufs[0], *next_buf = bufs[1];
 	char *retval = NULL;
 
 	/*
@@ -60,7 +60,7 @@ static const char *real_path_internal(const char *path, int die_on_error)
 			goto error_out;
 	}
 
-	if (strlcpy(buf, path, PATH_MAX) >= PATH_MAX) {
+	if (strlcpy(buf, path, GIT_MAX_PATH) >= GIT_MAX_PATH) {
 		if (die_on_error)
 			die("Too long path: %.*s", 60, path);
 		else
@@ -94,7 +94,7 @@ static const char *real_path_internal(const char *path, int die_on_error)
 					goto error_out;
 			}
 		}
-		if (!getcwd(buf, PATH_MAX)) {
+		if (!getcwd(buf, GIT_MAX_PATH)) {
 			if (die_on_error)
 				die_errno("Could not get current working directory");
 			else
@@ -103,7 +103,7 @@ static const char *real_path_internal(const char *path, int die_on_error)
 
 		if (last_elem) {
 			size_t len = strlen(buf);
-			if (len + strlen(last_elem) + 2 > PATH_MAX) {
+			if (len + strlen(last_elem) + 2 > GIT_MAX_PATH) {
 				if (die_on_error)
 					die("Too long path name: '%s/%s'",
 					    buf, last_elem);
@@ -118,14 +118,14 @@ static const char *real_path_internal(const char *path, int die_on_error)
 		}
 
 		if (!lstat(buf, &st) && S_ISLNK(st.st_mode)) {
-			ssize_t len = readlink(buf, next_buf, PATH_MAX);
+			ssize_t len = readlink(buf, next_buf, GIT_MAX_PATH);
 			if (len < 0) {
 				if (die_on_error)
 					die_errno("Invalid symlink '%s'", buf);
 				else
 					goto error_out;
 			}
-			if (PATH_MAX <= len) {
+			if (GIT_MAX_PATH <= len) {
 				if (die_on_error)
 					die("symbolic link too long: %s", buf);
 				else
@@ -160,10 +160,10 @@ const char *real_path_if_valid(const char *path)
 
 static const char *get_pwd_cwd(void)
 {
-	static char cwd[PATH_MAX + 1];
+	static char cwd[GIT_MAX_PATH + 1];
 	char *pwd;
 	struct stat cwd_stat, pwd_stat;
-	if (getcwd(cwd, PATH_MAX) == NULL)
+	if (getcwd(cwd, GIT_MAX_PATH) == NULL)
 		return NULL;
 	pwd = getenv("PWD");
 	if (pwd && strcmp(pwd, cwd)) {
@@ -172,7 +172,7 @@ static const char *get_pwd_cwd(void)
 		    !stat(pwd, &pwd_stat) &&
 		    pwd_stat.st_dev == cwd_stat.st_dev &&
 		    pwd_stat.st_ino == cwd_stat.st_ino) {
-			strlcpy(cwd, pwd, PATH_MAX);
+			strlcpy(cwd, pwd, GIT_MAX_PATH);
 		}
 	}
 	return cwd;
@@ -187,12 +187,12 @@ static const char *get_pwd_cwd(void)
  */
 const char *absolute_path(const char *path)
 {
-	static char buf[PATH_MAX + 1];
+	static char buf[GIT_MAX_PATH + 1];
 
 	if (!*path) {
 		die("The empty string is not a valid path");
 	} else if (is_absolute_path(path)) {
-		if (strlcpy(buf, path, PATH_MAX) >= PATH_MAX)
+		if (strlcpy(buf, path, GIT_MAX_PATH) >= GIT_MAX_PATH)
 			die("Too long path: %.*s", 60, path);
 	} else {
 		size_t len;
@@ -202,7 +202,7 @@ const char *absolute_path(const char *path)
 			die_errno("Cannot determine the current working directory");
 		len = strlen(cwd);
 		fmt = (len > 0 && is_dir_sep(cwd[len-1])) ? "%s%s" : "%s/%s";
-		if (snprintf(buf, PATH_MAX, fmt, cwd, path) >= PATH_MAX)
+		if (snprintf(buf, GIT_MAX_PATH, fmt, cwd, path) >= GIT_MAX_PATH)
 			die("Too long path: %.*s", 60, path);
 	}
 	return buf;
@@ -215,7 +215,7 @@ const char *absolute_path(const char *path)
  */
 const char *prefix_filename(const char *pfx, int pfx_len, const char *arg)
 {
-	static char path[PATH_MAX];
+	static char path[GIT_MAX_PATH];
 #ifndef WIN32
 	if (!pfx_len || is_absolute_path(arg))
 		return arg;
diff --git a/archive.c b/archive.c
index d254fa5..bbd8d22 100644
--- a/archive.c
+++ b/archive.c
@@ -116,7 +116,7 @@ static int write_archive_entry(const unsigned char *sha1, const char *base,
 
 	args->convert = 0;
 	strbuf_reset(&path);
-	strbuf_grow(&path, PATH_MAX);
+	strbuf_grow(&path, GIT_MAX_PATH);
 	strbuf_add(&path, args->base, args->baselen);
 	strbuf_add(&path, base, baselen);
 	strbuf_addstr(&path, filename);
diff --git a/branch.c b/branch.c
index 97c72bf..e5e37a5 100644
--- a/branch.c
+++ b/branch.c
@@ -219,7 +219,7 @@ void create_branch(const char *head,
 	struct ref_lock *lock = NULL;
 	struct commit *commit;
 	unsigned char sha1[20];
-	char *real_ref, msg[PATH_MAX + 20];
+	char *real_ref, msg[GIT_MAX_PATH + 20];
 	struct strbuf ref = STRBUF_INIT;
 	int forcing = 0;
 	int dont_change_ref = 0;
diff --git a/builtin/apply.c b/builtin/apply.c
index 30eefc3..59df9ef 100644
--- a/builtin/apply.c
+++ b/builtin/apply.c
@@ -3928,7 +3928,7 @@ static void create_one_file(char *path, unsigned mode, const char *buf, unsigned
 		unsigned int nr = getpid();
 
 		for (;;) {
-			char newpath[PATH_MAX];
+			char newpath[GIT_MAX_PATH];
 			mksnpath(newpath, sizeof(newpath), "%s~%u", path, nr);
 			if (!try_create_file(newpath, mode, buf, size)) {
 				if (!rename(newpath, path))
@@ -4014,7 +4014,7 @@ static void write_out_one_result(struct patch *patch, int phase)
 static int write_out_one_reject(struct patch *patch)
 {
 	FILE *rej;
-	char namebuf[PATH_MAX];
+	char namebuf[GIT_MAX_PATH];
 	struct fragment *frag;
 	int cnt = 0;
 	struct strbuf sb = STRBUF_INIT;
diff --git a/builtin/bundle.c b/builtin/bundle.c
index 92a8a60..3999ee1 100644
--- a/builtin/bundle.c
+++ b/builtin/bundle.c
@@ -20,7 +20,7 @@ int cmd_bundle(int argc, const char **argv, const char *prefix)
 	struct bundle_header header;
 	const char *cmd, *bundle_file;
 	int bundle_fd = -1;
-	char buffer[PATH_MAX];
+	char buffer[GIT_MAX_PATH];
 
 	if (argc < 3)
 		usage(builtin_bundle_usage);
diff --git a/builtin/checkout-index.c b/builtin/checkout-index.c
index b1feda7..8e2a845 100644
--- a/builtin/checkout-index.c
+++ b/builtin/checkout-index.c
@@ -14,7 +14,7 @@
 static int line_termination = '\n';
 static int checkout_stage; /* default to checkout stage0 */
 static int to_tempfile;
-static char topath[4][PATH_MAX + 1];
+static char topath[4][GIT_MAX_PATH + 1];
 
 static struct checkout state;
 
diff --git a/builtin/checkout.c b/builtin/checkout.c
index 81b4419..0671ae0 100644
--- a/builtin/checkout.c
+++ b/builtin/checkout.c
@@ -592,7 +592,7 @@ static void update_refs_for_switch(const struct checkout_opts *opts,
 		if (opts->new_orphan_branch) {
 			if (opts->new_branch_log && !log_all_ref_updates) {
 				int temp;
-				char log_file[PATH_MAX];
+				char log_file[GIT_MAX_PATH];
 				char *ref_name = mkpath("refs/heads/%s", opts->new_orphan_branch);
 
 				temp = log_all_ref_updates;
@@ -654,7 +654,7 @@ static void update_refs_for_switch(const struct checkout_opts *opts,
 			}
 		}
 		if (old->path && old->name) {
-			char log_file[PATH_MAX], ref_file[PATH_MAX];
+			char log_file[GIT_MAX_PATH], ref_file[GIT_MAX_PATH];
 
 			git_snpath(log_file, sizeof(log_file), "logs/%s", old->path);
 			git_snpath(ref_file, sizeof(ref_file), "%s", old->path);
diff --git a/builtin/clone.c b/builtin/clone.c
index a1386e5..a913ad5 100644
--- a/builtin/clone.c
+++ b/builtin/clone.c
@@ -285,7 +285,7 @@ static void copy_alternates(struct strbuf *src, struct strbuf *dst,
 	struct strbuf line = STRBUF_INIT;
 
 	while (strbuf_getline(&line, in, '\n') != EOF) {
-		char *abs_path, abs_buf[PATH_MAX];
+		char *abs_path, abs_buf[GIT_MAX_PATH];
 		if (!line.len || line.buf[0] == '#')
 			continue;
 		if (is_absolute_path(line.buf)) {
diff --git a/builtin/commit.c b/builtin/commit.c
index d2f30d9..cb0e4fb 100644
--- a/builtin/commit.c
+++ b/builtin/commit.c
@@ -825,7 +825,7 @@ static int prepare_to_commit(const char *index_file, const char *prefix,
 		return 0;
 
 	if (use_editor) {
-		char index[PATH_MAX];
+		char index[GIT_MAX_PATH];
 		const char *env[2] = { NULL };
 		env[0] =  index;
 		snprintf(index, sizeof(index), "GIT_INDEX_FILE=%s", index_file);
diff --git a/builtin/fsck.c b/builtin/fsck.c
index bb9a2cd..9da4764 100644
--- a/builtin/fsck.c
+++ b/builtin/fsck.c
@@ -650,7 +650,7 @@ int cmd_fsck(int argc, const char **argv, const char *prefix)
 
 	prepare_alt_odb();
 	for (alt = alt_odb_list; alt; alt = alt->next) {
-		char namebuf[PATH_MAX];
+		char namebuf[GIT_MAX_PATH];
 		int namelen = alt->name - alt->base;
 		memcpy(namebuf, alt->base, namelen);
 		namebuf[namelen - 1] = 0;
diff --git a/builtin/gc.c b/builtin/gc.c
index 6be6c8d..139cc6f 100644
--- a/builtin/gc.c
+++ b/builtin/gc.c
@@ -75,7 +75,7 @@ static int too_many_loose_objects(void)
 	 * distributed, we can check only one and get a reasonable
 	 * estimate.
 	 */
-	char path[PATH_MAX];
+	char path[GIT_MAX_PATH];
 	const char *objdir = get_object_directory();
 	DIR *dir;
 	struct dirent *ent;
diff --git a/builtin/grep.c b/builtin/grep.c
index 12e2849..2321ef2 100644
--- a/builtin/grep.c
+++ b/builtin/grep.c
@@ -501,7 +501,7 @@ static int grep_object(struct grep_opt *opt, const struct pathspec *pathspec,
 			die(_("unable to read tree (%s)"), sha1_to_hex(obj->sha1));
 
 		len = name ? strlen(name) : 0;
-		strbuf_init(&base, PATH_MAX + len + 1);
+		strbuf_init(&base, GIT_MAX_PATH + len + 1);
 		if (len) {
 			strbuf_add(&base, name, len);
 			strbuf_addch(&base, ':');
diff --git a/builtin/index-pack.c b/builtin/index-pack.c
index 79dfe47..60c073f 100644
--- a/builtin/index-pack.c
+++ b/builtin/index-pack.c
@@ -275,7 +275,7 @@ static const char *open_pack_file(const char *pack_name)
 	if (from_stdin) {
 		input_fd = 0;
 		if (!pack_name) {
-			static char tmp_file[PATH_MAX];
+			static char tmp_file[GIT_MAX_PATH];
 			output_fd = odb_mkstemp(tmp_file, sizeof(tmp_file),
 						"pack/tmp_pack_XXXXXX");
 			pack_name = xstrdup(tmp_file);
@@ -1262,7 +1262,7 @@ static void final(const char *final_pack_name, const char *curr_pack_name,
 		  unsigned char *sha1)
 {
 	const char *report = "pack";
-	char name[PATH_MAX];
+	char name[GIT_MAX_PATH];
 	int err;
 
 	if (!from_stdin) {
diff --git a/builtin/init-db.c b/builtin/init-db.c
index a890293..7be2c5d 100644
--- a/builtin/init-db.c
+++ b/builtin/init-db.c
@@ -57,8 +57,8 @@ static void copy_templates_1(char *path, int baselen,
 		if (de->d_name[0] == '.')
 			continue;
 		namelen = strlen(de->d_name);
-		if ((PATH_MAX <= baselen + namelen) ||
-		    (PATH_MAX <= template_baselen + namelen))
+		if ((GIT_MAX_PATH <= baselen + namelen) ||
+		    (GIT_MAX_PATH <= template_baselen + namelen))
 			die(_("insanely long template name %s"), de->d_name);
 		memcpy(path + baselen, de->d_name, namelen+1);
 		memcpy(template + template_baselen, de->d_name, namelen+1);
@@ -113,8 +113,8 @@ static void copy_templates_1(char *path, int baselen,
 
 static void copy_templates(const char *template_dir)
 {
-	char path[PATH_MAX];
-	char template_path[PATH_MAX];
+	char path[GIT_MAX_PATH];
+	char template_path[GIT_MAX_PATH];
 	int template_len;
 	DIR *dir;
 	const char *git_dir = get_git_dir();
@@ -129,7 +129,7 @@ static void copy_templates(const char *template_dir)
 	if (!template_dir[0])
 		return;
 	template_len = strlen(template_dir);
-	if (PATH_MAX <= (template_len+strlen("/config")))
+	if (GIT_MAX_PATH <= (template_len+strlen("/config")))
 		die(_("insanely long template path %s"), template_dir);
 	strcpy(template_path, template_dir);
 	if (template_path[template_len-1] != '/') {
@@ -181,7 +181,7 @@ static int create_default_files(const char *template_path)
 {
 	const char *git_dir = get_git_dir();
 	unsigned len = strlen(git_dir);
-	static char path[PATH_MAX];
+	static char path[GIT_MAX_PATH];
 	struct stat st1;
 	char repo_version_string[10];
 	char junk[2];
@@ -429,7 +429,7 @@ int init_db(const char *template_dir, unsigned int flags)
 
 static int guess_repository_type(const char *git_dir)
 {
-	char cwd[PATH_MAX];
+	char cwd[GIT_MAX_PATH];
 	const char *slash;
 
 	/*
@@ -537,7 +537,7 @@ int cmd_init_db(int argc, const char **argv, const char *prefix)
 		usage(init_db_usage[0]);
 	}
 	if (is_bare_repository_cfg == 1) {
-		static char git_dir[PATH_MAX+1];
+		static char git_dir[GIT_MAX_PATH+1];
 
 		setenv(GIT_DIR_ENVIRONMENT,
 			getcwd(git_dir, sizeof(git_dir)), argc > 0);
@@ -575,8 +575,8 @@ int cmd_init_db(int argc, const char **argv, const char *prefix)
 			free(rel);
 		}
 		if (!git_work_tree_cfg) {
-			git_work_tree_cfg = xcalloc(PATH_MAX, 1);
-			if (!getcwd(git_work_tree_cfg, PATH_MAX))
+			git_work_tree_cfg = xcalloc(GIT_MAX_PATH, 1);
+			if (!getcwd(git_work_tree_cfg, GIT_MAX_PATH))
 				die_errno (_("Cannot access current working directory"));
 		}
 		if (work_tree)
diff --git a/builtin/log.c b/builtin/log.c
index 6e56a50..9321901 100644
--- a/builtin/log.c
+++ b/builtin/log.c
@@ -716,7 +716,7 @@ static int reopen_stdout(struct commit *commit, const char *subject,
 	if (output_directory) {
 		strbuf_addstr(&filename, output_directory);
 		if (filename.len >=
-		    PATH_MAX - FORMAT_PATCH_NAME_MAX - suffix_len)
+		    GIT_MAX_PATH - FORMAT_PATCH_NAME_MAX - suffix_len)
 			return error(_("name of output directory is too long"));
 		if (filename.buf[filename.len - 1] != '/')
 			strbuf_addch(&filename, '/');
diff --git a/builtin/ls-remote.c b/builtin/ls-remote.c
index 25e83cf..cf65934 100644
--- a/builtin/ls-remote.c
+++ b/builtin/ls-remote.c
@@ -14,7 +14,7 @@ static const char ls_remote_usage[] =
 static int tail_match(const char **pattern, const char *path)
 {
 	const char *p;
-	char pathbuf[PATH_MAX];
+	char pathbuf[GIT_MAX_PATH];
 
 	if (!pattern)
 		return 1; /* no restriction */
diff --git a/builtin/mailsplit.c b/builtin/mailsplit.c
index 06296d4..baa01f9 100644
--- a/builtin/mailsplit.c
+++ b/builtin/mailsplit.c
@@ -104,7 +104,7 @@ static int populate_maildir_list(struct string_list *list, const char *path)
 {
 	DIR *dir;
 	struct dirent *dent;
-	char name[PATH_MAX];
+	char name[GIT_MAX_PATH];
 	char *subs[] = { "cur", "new", NULL };
 	char **sub;
 
@@ -154,8 +154,8 @@ static int maildir_filename_cmp(const char *a, const char *b)
 static int split_maildir(const char *maildir, const char *dir,
 	int nr_prec, int skip)
 {
-	char file[PATH_MAX];
-	char name[PATH_MAX];
+	char file[GIT_MAX_PATH];
+	char name[GIT_MAX_PATH];
 	int ret = -1;
 	int i;
 	struct string_list list = STRING_LIST_INIT_DUP;
@@ -194,7 +194,7 @@ out:
 static int split_mbox(const char *file, const char *dir, int allow_bare,
 		      int nr_prec, int skip)
 {
-	char name[PATH_MAX];
+	char name[GIT_MAX_PATH];
 	int ret = -1;
 	int peek;
 
diff --git a/builtin/pack-objects.c b/builtin/pack-objects.c
index f069462..0c638c1 100644
--- a/builtin/pack-objects.c
+++ b/builtin/pack-objects.c
@@ -763,7 +763,7 @@ static void write_pack_file(void)
 
 		if (!pack_to_stdout) {
 			struct stat st;
-			char tmpname[PATH_MAX];
+			char tmpname[GIT_MAX_PATH];
 
 			/*
 			 * Packs are runtime accessed in their mtime
@@ -2164,7 +2164,7 @@ static int git_pack_config(const char *k, const char *v, void *cb)
 
 static void read_object_list_from_stdin(void)
 {
-	char line[40 + 1 + PATH_MAX + 2];
+	char line[40 + 1 + GIT_MAX_PATH + 2];
 	unsigned char sha1[20];
 
 	for (;;) {
diff --git a/builtin/prune-packed.c b/builtin/prune-packed.c
index 83382c1..d3c7e7c 100644
--- a/builtin/prune-packed.c
+++ b/builtin/prune-packed.c
@@ -40,7 +40,7 @@ static void prune_dir(int i, DIR *dir, char *pathname, int len, int opts)
 void prune_packed_objects(int opts)
 {
 	int i;
-	static char pathname[PATH_MAX];
+	static char pathname[GIT_MAX_PATH];
 	const char *dir = get_object_directory();
 	int len = strlen(dir);
 
@@ -48,7 +48,7 @@ void prune_packed_objects(int opts)
 		progress = start_progress_delay("Removing duplicate objects",
 			256, 95, 2);
 
-	if (len > PATH_MAX - 42)
+	if (len > GIT_MAX_PATH - 42)
 		die("impossible object directory");
 	memcpy(pathname, dir, len);
 	if (len && pathname[len-1] != '/')
diff --git a/builtin/replace.c b/builtin/replace.c
index 398ccd5..8991cbd 100644
--- a/builtin/replace.c
+++ b/builtin/replace.c
@@ -47,7 +47,7 @@ typedef int (*each_replace_name_fn)(const char *name, const char *ref,
 static int for_each_replace_name(const char **argv, each_replace_name_fn fn)
 {
 	const char **p, *full_hex;
-	char ref[PATH_MAX];
+	char ref[GIT_MAX_PATH];
 	int had_error = 0;
 	unsigned char sha1[20];
 
@@ -85,7 +85,7 @@ static int replace_object(const char *object_ref, const char *replace_ref,
 			  int force)
 {
 	unsigned char object[20], prev[20], repl[20];
-	char ref[PATH_MAX];
+	char ref[GIT_MAX_PATH];
 	struct ref_lock *lock;
 
 	if (get_sha1(object_ref, object))
diff --git a/builtin/rev-parse.c b/builtin/rev-parse.c
index f267a1d..1270d28 100644
--- a/builtin/rev-parse.c
+++ b/builtin/rev-parse.c
@@ -681,7 +681,7 @@ int cmd_rev_parse(int argc, const char **argv, const char *prefix)
 			}
 			if (!strcmp(arg, "--git-dir")) {
 				const char *gitdir = getenv(GIT_DIR_ENVIRONMENT);
-				static char cwd[PATH_MAX];
+				static char cwd[GIT_MAX_PATH];
 				int len;
 				if (gitdir) {
 					puts(gitdir);
@@ -691,7 +691,7 @@ int cmd_rev_parse(int argc, const char **argv, const char *prefix)
 					puts(".git");
 					continue;
 				}
-				if (!getcwd(cwd, PATH_MAX))
+				if (!getcwd(cwd, GIT_MAX_PATH))
 					die_errno("unable to get current working directory");
 				len = strlen(cwd);
 				printf("%s%s.git\n", cwd, len && cwd[len-1] != '/' ? "/" : "");
diff --git a/builtin/tag.c b/builtin/tag.c
index af3af3f..adc973a 100644
--- a/builtin/tag.c
+++ b/builtin/tag.c
@@ -197,7 +197,7 @@ typedef int (*each_tag_name_fn)(const char *name, const char *ref,
 static int for_each_tag_name(const char **argv, each_tag_name_fn fn)
 {
 	const char **p;
-	char ref[PATH_MAX];
+	char ref[GIT_MAX_PATH];
 	int had_error = 0;
 	unsigned char sha1[20];
 
diff --git a/bulk-checkin.c b/bulk-checkin.c
index 6b0b6d4..c57fe3d 100644
--- a/bulk-checkin.c
+++ b/bulk-checkin.c
@@ -23,7 +23,7 @@ static struct bulk_checkin_state {
 static void finish_bulk_checkin(struct bulk_checkin_state *state)
 {
 	unsigned char sha1[20];
-	char packname[PATH_MAX];
+	char packname[GIT_MAX_PATH];
 	int i;
 
 	if (!state->f)
diff --git a/cache.h b/cache.h
index 1f6a225..4a10510 100644
--- a/cache.h
+++ b/cache.h
@@ -524,7 +524,7 @@ struct lock_file {
 	int fd;
 	pid_t owner;
 	char on_list;
-	char filename[PATH_MAX];
+	char filename[GIT_MAX_PATH];
 };
 #define LOCK_DIE_ON_ERROR 1
 #define LOCK_NODEREF 2
@@ -805,7 +805,7 @@ static inline unsigned int hexval(unsigned char c)
 
 struct object_context {
 	unsigned char tree[20];
-	char path[PATH_MAX];
+	char path[GIT_MAX_PATH];
 	unsigned mode;
 };
 
@@ -962,7 +962,7 @@ struct checkout {
 extern int checkout_entry(struct cache_entry *ce, const struct checkout *state, char *topath);
 
 struct cache_def {
-	char path[PATH_MAX + 1];
+	char path[GIT_MAX_PATH + 1];
 	int len;
 	int flags;
 	int track_flags;
diff --git a/compat/mingw.c b/compat/mingw.c
index 96d9ac4..efb282f 100644
--- a/compat/mingw.c
+++ b/compat/mingw.c
@@ -204,7 +204,7 @@ static int ask_yes_no_if_possible(const char *format, ...)
 int mingw_unlink(const char *pathname)
 {
 	int ret, tries = 0;
-	wchar_t wpathname[MAX_PATH];
+	wchar_t wpathname[GIT_MAX_PATH];
 	if (xutftowcs_path(wpathname, pathname) < 0)
 		return -1;
 
@@ -234,7 +234,7 @@ static int is_dir_empty(const wchar_t *wpath)
 {
 	WIN32_FIND_DATAW findbuf;
 	HANDLE handle;
-	wchar_t wbuf[MAX_PATH + 2];
+	wchar_t wbuf[GIT_MAX_PATH + 2];
 	wcscpy(wbuf, wpath);
 	wcscat(wbuf, L"\\*");
 	handle = FindFirstFileW(wbuf, &findbuf);
@@ -255,7 +255,7 @@ static int is_dir_empty(const wchar_t *wpath)
 int mingw_rmdir(const char *pathname)
 {
 	int ret, tries = 0;
-	wchar_t wpathname[MAX_PATH];
+	wchar_t wpathname[GIT_MAX_PATH];
 	if (xutftowcs_path(wpathname, pathname) < 0)
 		return -1;
 
@@ -296,7 +296,7 @@ static int make_hidden(const wchar_t *path)
 
 void mingw_mark_as_git_dir(const char *dir)
 {
-	wchar_t wdir[MAX_PATH];
+	wchar_t wdir[GIT_MAX_PATH];
 	if (hide_dotfiles != HIDE_DOTFILES_FALSE && !is_bare_repository())
 		if (xutftowcs_path(wdir, dir) < 0 || make_hidden(wdir))
 			warning("Failed to make '%s' hidden", dir);
@@ -309,7 +309,7 @@ void mingw_mark_as_git_dir(const char *dir)
 int mingw_mkdir(const char *path, int mode)
 {
 	int ret;
-	wchar_t wpath[MAX_PATH];
+	wchar_t wpath[GIT_MAX_PATH];
 	if (xutftowcs_path(wpath, path) < 0)
 		return -1;
 	ret = _wmkdir(wpath);
@@ -331,7 +331,8 @@ int mingw_open (const char *filename, int oflags, ...)
 	va_list args;
 	unsigned mode;
 	int fd;
-	wchar_t wfilename[MAX_PATH];
+	int filenameLength;
+	wchar_t wfilename[GIT_MAX_PATH];
 
 	va_start(args, oflags);
 	mode = va_arg(args, int);
@@ -340,7 +341,7 @@ int mingw_open (const char *filename, int oflags, ...)
 	if (filename && !strcmp(filename, "/dev/null"))
 		filename = "nul";
 
-	if (xutftowcs_path(wfilename, filename) < 0)
+	if ((filenameLength = xutftowcs_path(wfilename, filename)) < 0)
 		return -1;
 	fd = _wopen(wfilename, oflags, mode);
 
@@ -410,7 +411,7 @@ FILE *mingw_fopen (const char *filename, const char *otype)
 {
 	int hide = 0;
 	FILE *file;
-	wchar_t wfilename[MAX_PATH], wotype[4];
+	wchar_t wfilename[GIT_MAX_PATH], wotype[4];
 	if (hide_dotfiles == HIDE_DOTFILES_TRUE &&
 	    basename((char*)filename)[0] == '.')
 		hide = access(filename, F_OK);
@@ -429,7 +430,7 @@ FILE *mingw_freopen (const char *filename, const char *otype, FILE *stream)
 {
 	int hide = 0;
 	FILE *file;
-	wchar_t wfilename[MAX_PATH], wotype[4];
+	wchar_t wfilename[GIT_MAX_PATH], wotype[4];
 	if (hide_dotfiles == HIDE_DOTFILES_TRUE &&
 	    basename((char*)filename)[0] == '.')
 		hide = access(filename, F_OK);
@@ -468,7 +469,7 @@ int mingw_fflush(FILE *stream)
 
 int mingw_access(const char *filename, int mode)
 {
-	wchar_t wfilename[MAX_PATH];
+	wchar_t wfilename[GIT_MAX_PATH];
 	if (xutftowcs_path(wfilename, filename) < 0)
 		return -1;
 	/* X_OK is not supported by the MSVCRT version */
@@ -477,7 +478,7 @@ int mingw_access(const char *filename, int mode)
 
 int mingw_chdir(const char *dirname)
 {
-	wchar_t wdirname[MAX_PATH];
+	wchar_t wdirname[GIT_MAX_PATH];
 	if (xutftowcs_path(wdirname, dirname) < 0)
 		return -1;
 	return _wchdir(wdirname);
@@ -485,7 +486,7 @@ int mingw_chdir(const char *dirname)
 
 int mingw_chmod(const char *filename, int mode)
 {
-	wchar_t wfilename[MAX_PATH];
+	wchar_t wfilename[GIT_MAX_PATH];
 	if (xutftowcs_path(wfilename, filename) < 0)
 		return -1;
 	return _wchmod(wfilename, mode);
@@ -517,7 +518,7 @@ static inline time_t filetime_to_time_t(const FILETIME *ft)
 static int do_lstat(int follow, const char *file_name, struct stat *buf)
 {
 	WIN32_FILE_ATTRIBUTE_DATA fdata;
-	wchar_t wfilename[MAX_PATH];
+	wchar_t wfilename[GIT_MAX_PATH];
 	if (xutftowcs_path(wfilename, file_name) < 0)
 		return -1;
 
@@ -583,7 +584,7 @@ static int do_lstat(int follow, const char *file_name, struct stat *buf)
 static int do_stat_internal(int follow, const char *file_name, struct stat *buf)
 {
 	int namelen;
-	char alt_name[PATH_MAX];
+	char alt_name[GIT_MAX_PATH];
 
 	if (!do_lstat(follow, file_name, buf))
 		return 0;
@@ -599,7 +600,7 @@ static int do_stat_internal(int follow, const char *file_name, struct stat *buf)
 		return -1;
 	while (namelen && file_name[namelen-1] == '/')
 		--namelen;
-	if (!namelen || namelen >= PATH_MAX)
+	if (!namelen || namelen >= GIT_MAX_PATH)
 		return -1;
 
 	memcpy(alt_name, file_name, namelen);
@@ -660,7 +661,7 @@ int mingw_utime (const char *file_name, const struct utimbuf *times)
 	FILETIME mft, aft;
 	int fh, rc;
 	DWORD attrs;
-	wchar_t wfilename[MAX_PATH];
+	wchar_t wfilename[GIT_MAX_PATH];
 	if (xutftowcs_path(wfilename, file_name) < 0)
 		return -1;
 
@@ -708,7 +709,7 @@ unsigned int sleep (unsigned int seconds)
 
 char *mingw_mktemp(char *template)
 {
-	wchar_t wtemplate[MAX_PATH];
+	wchar_t wtemplate[GIT_MAX_PATH];
 	if (xutftowcs_path(wtemplate, template) < 0)
 		return NULL;
 	if (!_wmktemp(wtemplate))
@@ -779,7 +780,7 @@ struct tm *localtime_r(const time_t *timep, struct tm *result)
 char *mingw_getcwd(char *pointer, int len)
 {
 	int i;
-	wchar_t wpointer[MAX_PATH];
+	wchar_t wpointer[GIT_MAX_PATH];
 	if (!_wgetcwd(wpointer, ARRAY_SIZE(wpointer)))
 		return NULL;
 	if (xwcstoutf(pointer, wpointer, len) < 0)
@@ -1030,8 +1031,8 @@ static void free_path_split(char **path)
  */
 static char *lookup_prog(const char *dir, const char *cmd, int isexe, int exe_only)
 {
-	char path[MAX_PATH];
-	wchar_t wpath[MAX_PATH];
+	char path[GIT_MAX_PATH];
+	wchar_t wpath[GIT_MAX_PATH];
 	snprintf(path, sizeof(path), "%s\\%s.exe", dir, cmd);
 
 	if (xutftowcs_path(wpath, path) < 0)
@@ -1116,7 +1117,7 @@ static pid_t mingw_spawnve_fd(const char *cmd, const char **argv, char **deltaen
 	STARTUPINFOW si;
 	PROCESS_INFORMATION pi;
 	struct strbuf args;
-	wchar_t wcmd[MAX_PATH], wdir[MAX_PATH], *wargs, *wenvblk = NULL;
+	wchar_t wcmd[GIT_MAX_PATH], wdir[GIT_MAX_PATH], *wargs, *wenvblk = NULL;
 	unsigned flags = CREATE_UNICODE_ENVIRONMENT;
 	BOOL ret;
 
@@ -1637,7 +1638,7 @@ int mingw_rename(const char *pold, const char *pnew)
 {
 	DWORD attrs, gle;
 	int tries = 0;
-	wchar_t wpold[MAX_PATH], wpnew[MAX_PATH];
+	wchar_t wpold[GIT_MAX_PATH], wpnew[GIT_MAX_PATH];
 	if (xutftowcs_path(wpold, pold) < 0 || xutftowcs_path(wpnew, pnew) < 0)
 		return -1;
 
@@ -1870,10 +1871,10 @@ int mingw_raise(int sig)
 
 static const char *make_backslash_path(const char *path)
 {
-	static char buf[PATH_MAX + 1];
+	static char buf[GIT_MAX_PATH + 1];
 	char *c;
 
-	if (strlcpy(buf, path, PATH_MAX) >= PATH_MAX)
+	if (strlcpy(buf, path, GIT_MAX_PATH) >= GIT_MAX_PATH)
 		die("Too long path: %.*s", 60, path);
 
 	for (c = buf; *c; c++) {
@@ -1904,7 +1905,7 @@ void mingw_open_html(const char *unixpath)
 	FreeLibrary(shell32);
 	/* see the MSDN documentation referring to the result codes here */
 	if (r <= 32) {
-		die("failed to launch browser for %.*s", MAX_PATH, unixpath);
+		die("failed to launch browser for %.*s", GIT_MAX_PATH, unixpath);
 	}
 }
 
@@ -1912,7 +1913,7 @@ int link(const char *oldpath, const char *newpath)
 {
 	typedef BOOL (WINAPI *T)(LPCWSTR, LPCWSTR, LPSECURITY_ATTRIBUTES);
 	static T create_hard_link = NULL;
-	wchar_t woldpath[MAX_PATH], wnewpath[MAX_PATH];
+	wchar_t woldpath[GIT_MAX_PATH], wnewpath[GIT_MAX_PATH];
 	if (xutftowcs_path(woldpath, oldpath) < 0 ||
 		xutftowcs_path(wnewpath, newpath) < 0)
 		return -1;
diff --git a/compat/mingw.h b/compat/mingw.h
index 8848c7b..e849a16 100644
--- a/compat/mingw.h
+++ b/compat/mingw.h
@@ -400,15 +400,31 @@ static inline int xutftowcs(wchar_t *wcs, const char *utf, size_t wcslen)
 
 /**
  * Simplified file system specific variant of xutftowcsn, assumes output
- * buffer size is MAX_PATH wide chars and input string is \0-terminated,
+ * buffer size is GIT_MAX_PATH wide chars and input string is \0-terminated,
  * fails with ENAMETOOLONG if input string is too long.
  */
 static inline int xutftowcs_path(wchar_t *wcs, const char *utf)
 {
-	int result = xutftowcsn(wcs, utf, MAX_PATH, -1);
-	if (result < 0 && errno == ERANGE)
+	wchar_t buf[GIT_MAX_PATH - 4];
+
+	int result = xutftowcsn(wcs, utf, GIT_MAX_PATH - 4, -1);
+	if (result < 0 && errno == ERANGE) {
 		errno = ENAMETOOLONG;
-	return result;
+		return result;
+	}
+
+	result = GetFullPathNameW(wcs, GIT_MAX_PATH - 4, buf, NULL);
+	if (wcsncmp(buf, L"\\\\?\\", 4) == 0) {
+		memcpy(wcs, buf, sizeof(buf));
+		return result;
+	}
+
+	wcs[0] = L'\\';
+	wcs[1] = L'\\';
+	wcs[2] = L'?';
+	wcs[3] = L'\\';
+	memcpy(wcs + 4, buf, sizeof(buf));
+	return result + 4;
 }
 
 /**
diff --git a/compat/win32/dirent.c b/compat/win32/dirent.c
index 52420ec..20103a4 100644
--- a/compat/win32/dirent.c
+++ b/compat/win32/dirent.c
@@ -20,20 +20,20 @@ static inline void finddata2dirent(struct dirent *ent, WIN32_FIND_DATAW *fdata)
 
 DIR *opendir(const char *name)
 {
-	wchar_t pattern[MAX_PATH + 2]; /* + 2 for '/' '*' */
+	wchar_t pattern[GIT_MAX_PATH + 2 ]; /* + 2 for '/' '*' */
 	WIN32_FIND_DATAW fdata;
 	HANDLE h;
 	int len;
 	DIR *dir;
 
-	/* convert name to UTF-16 and check length < MAX_PATH */
+	/* convert name to UTF-16 and check length < GIT_MAX_PATH */
 	if ((len = xutftowcs_path(pattern, name)) < 0)
 		return NULL;
 
 	/* append optional '/' and wildcard '*' */
 	if (len && !is_dir_sep(pattern[len - 1]))
-		pattern[len++] = '/';
-	pattern[len++] = '*';
+		pattern[len++] = L'\\';
+	pattern[len++] = L'*';
 	pattern[len] = 0;
 
 	/* open find handle */
diff --git a/compat/win32/dirent.h b/compat/win32/dirent.h
index 058207e..9c3917d 100644
--- a/compat/win32/dirent.h
+++ b/compat/win32/dirent.h
@@ -10,7 +10,7 @@ typedef struct DIR DIR;
 
 struct dirent {
 	unsigned char d_type;      /* file type to prevent lstat after readdir */
-	char d_name[MAX_PATH * 3]; /* file name (* 3 for UTF-8 conversion) */
+	char d_name[GIT_MAX_PATH * 3]; /* file name (* 3 for UTF-8 conversion) */
 };
 
 DIR *opendir(const char *dirname);
diff --git a/daemon.c b/daemon.c
index 6aeddcb..b244599 100644
--- a/daemon.c
+++ b/daemon.c
@@ -108,8 +108,8 @@ static void NORETURN daemon_die(const char *err, va_list params)
 
 static const char *path_ok(char *directory)
 {
-	static char rpath[PATH_MAX];
-	static char interp_path[PATH_MAX];
+	static char rpath[GIT_MAX_PATH];
+	static char interp_path[GIT_MAX_PATH];
 	const char *path;
 	char *dir;
 
@@ -137,7 +137,7 @@ static const char *path_ok(char *directory)
 			namlen = slash - dir;
 			restlen -= namlen;
 			loginfo("userpath <%s>, request <%s>, namlen %d, restlen %d, slash <%s>", user_path, dir, namlen, restlen, slash);
-			snprintf(rpath, PATH_MAX, "%.*s/%s%.*s",
+			snprintf(rpath, GIT_MAX_PATH, "%.*s/%s%.*s",
 				 namlen, dir, user_path, restlen, slash);
 			dir = rpath;
 		}
@@ -160,7 +160,7 @@ static const char *path_ok(char *directory)
 
 		strbuf_expand(&expanded_path, interpolated_path,
 				strbuf_expand_dict_cb, &dict);
-		strlcpy(interp_path, expanded_path.buf, PATH_MAX);
+		strlcpy(interp_path, expanded_path.buf, GIT_MAX_PATH);
 		strbuf_release(&expanded_path);
 		loginfo("Interpolated dir '%s'", interp_path);
 
@@ -172,7 +172,7 @@ static const char *path_ok(char *directory)
 			logerror("'%s': Non-absolute path denied (base-path active)", dir);
 			return NULL;
 		}
-		snprintf(rpath, PATH_MAX, "%s%s", base_path, dir);
+		snprintf(rpath, GIT_MAX_PATH, "%s%s", base_path, dir);
 		dir = rpath;
 	}
 
diff --git a/diff.c b/diff.c
index f0b3e7c..1c7221f 100644
--- a/diff.c
+++ b/diff.c
@@ -306,7 +306,7 @@ static struct diff_tempfile {
 	const char *name; /* filename external diff should read from */
 	char hex[41];
 	char mode[10];
-	char tmp_path[PATH_MAX];
+	char tmp_path[GIT_MAX_PATH];
 } diff_temp[2];
 
 typedef unsigned long (*sane_truncate_fn)(char *line, unsigned long len);
@@ -2793,7 +2793,7 @@ static void prep_temp_blob(const char *path, struct diff_tempfile *temp,
 	strbuf_addstr(&template, "XXXXXX_");
 	strbuf_addstr(&template, base);
 
-	fd = git_mkstemps(temp->tmp_path, PATH_MAX, template.buf,
+	fd = git_mkstemps(temp->tmp_path, GIT_MAX_PATH, template.buf,
 			strlen(base) + 1);
 	if (fd < 0)
 		die_errno("unable to create temp-file");
@@ -2950,7 +2950,7 @@ static void fill_metainfo(struct strbuf *msg,
 	const char *line_prefix = diff_line_prefix(o);
 
 	*must_show_header = 1;
-	strbuf_init(msg, PATH_MAX * 2 + 300);
+	strbuf_init(msg, GIT_MAX_PATH * 2 + 300);
 	switch (p->status) {
 	case DIFF_STATUS_COPIED:
 		strbuf_addf(msg, "%s%ssimilarity index %d%%",
@@ -4239,7 +4239,7 @@ static int diff_get_patch_id(struct diff_options *options, unsigned char *sha1)
 	int i;
 	git_SHA_CTX ctx;
 	struct patch_id_t data;
-	char buffer[PATH_MAX * 4 + 20];
+	char buffer[GIT_MAX_PATH * 4 + 20];
 
 	git_SHA1_Init(&ctx);
 	memset(&data, 0, sizeof(struct patch_id_t));
diff --git a/diffcore-order.c b/diffcore-order.c
index 23e9385..fd32e33 100644
--- a/diffcore-order.c
+++ b/diffcore-order.c
@@ -73,7 +73,7 @@ struct pair_order {
 static int match_order(const char *path)
 {
 	int i;
-	char p[PATH_MAX];
+	char p[GIT_MAX_PATH];
 
 	for (i = 0; i < order_cnt; i++) {
 		strcpy(p, path);
diff --git a/dir.c b/dir.c
index 13858fe..43dac28 100644
--- a/dir.c
+++ b/dir.c
@@ -12,6 +12,7 @@
 #include "refs.h"
 #include "wildmatch.h"
 
+
 struct path_simplify {
 	int len;
 	const char *path;
@@ -833,7 +834,7 @@ static void prep_exclude(struct dir_struct *dir, const char *base, int baselen)
 
 		/* Try to read per-directory file unless path is too long */
 		if (dir->exclude_per_dir &&
-		    stk->baselen + strlen(dir->exclude_per_dir) < PATH_MAX) {
+		    stk->baselen + strlen(dir->exclude_per_dir) < GIT_MAX_PATH) {
 			strcpy(dir->basebuf + stk->baselen,
 					dir->exclude_per_dir);
 			/*
@@ -1439,7 +1440,7 @@ int dir_inside_of(const char *subdir, const char *dir)
 
 int is_inside_dir(const char *dir)
 {
-	char cwd[PATH_MAX];
+	char cwd[GIT_MAX_PATH];
 	if (!dir)
 		return 0;
 	if (!getcwd(cwd, sizeof(cwd)))
diff --git a/dir.h b/dir.h
index 3d6b80c..0c1cb26 100644
--- a/dir.h
+++ b/dir.h
@@ -116,7 +116,7 @@ struct dir_struct {
 	 */
 	struct exclude_stack *exclude_stack;
 	struct exclude *exclude;
-	char basebuf[PATH_MAX];
+	char basebuf[GIT_MAX_PATH];
 };
 
 /*
diff --git a/entry.c b/entry.c
index d7c131d..6e56384 100644
--- a/entry.c
+++ b/entry.c
@@ -48,7 +48,7 @@ static void remove_subtree(const char *path)
 {
 	DIR *dir = opendir(path);
 	struct dirent *de;
-	char pathbuf[PATH_MAX];
+	char pathbuf[GIT_MAX_PATH];
 	char *name;
 
 	if (!dir)
@@ -235,7 +235,7 @@ static int check_path(const char *path, int len, struct stat *st, int skiplen)
 
 int checkout_entry(struct cache_entry *ce, const struct checkout *state, char *topath)
 {
-	static char path[PATH_MAX + 1];
+	static char path[GIT_MAX_PATH + 1];
 	struct stat st;
 	int len = state->base_dir_len;
 
diff --git a/fast-import.c b/fast-import.c
index 5f539d7..90d4dcc 100644
--- a/fast-import.c
+++ b/fast-import.c
@@ -493,7 +493,7 @@ static void dump_marks(void);
 static NORETURN void die_nicely(const char *err, va_list params)
 {
 	static int zombie;
-	char message[2 * PATH_MAX];
+	char message[2 * GIT_MAX_PATH];
 
 	vsnprintf(message, sizeof(message), err, params);
 	fputs("fatal: ", stderr);
@@ -855,7 +855,7 @@ static struct tree_content *dup_tree_content(struct tree_content *s)
 
 static void start_packfile(void)
 {
-	static char tmp_file[PATH_MAX];
+	static char tmp_file[GIT_MAX_PATH];
 	struct packed_git *p;
 	struct pack_header hdr;
 	int pack_fd;
@@ -906,7 +906,7 @@ static const char *create_index(void)
 
 static char *keep_pack(const char *curr_index_name)
 {
-	static char name[PATH_MAX];
+	static char name[GIT_MAX_PATH];
 	static const char *keep_msg = "fast-import";
 	int keep_fd;
 
@@ -932,7 +932,7 @@ static char *keep_pack(const char *curr_index_name)
 
 static void unkeep_all_packs(void)
 {
-	static char name[PATH_MAX];
+	static char name[GIT_MAX_PATH];
 	int k;
 
 	for (k = 0; k < pack_id; k++) {
@@ -1720,7 +1720,7 @@ static void dump_tags(void)
 	static const char *msg = "fast-import";
 	struct tag *t;
 	struct ref_lock *lock;
-	char ref_name[PATH_MAX];
+	char ref_name[GIT_MAX_PATH];
 
 	for (t = first_tag; t; t = t->next_tag) {
 		sprintf(ref_name, "tags/%s", t->name);
diff --git a/git-compat-util.h b/git-compat-util.h
index be1c494..a959845 100644
--- a/git-compat-util.h
+++ b/git-compat-util.h
@@ -1,6 +1,7 @@
 #ifndef GIT_COMPAT_UTIL_H
 #define GIT_COMPAT_UTIL_H
 
+#define GIT_MAX_PATH 4096
 #define _FILE_OFFSET_BITS 64
 
 #ifndef FLEX_ARRAY
diff --git a/git.c b/git.c
index 1ada169..f6f9470 100644
--- a/git.c
+++ b/git.c
@@ -124,7 +124,7 @@ static int handle_options(const char ***argv, int *argc, int *envchanged)
 			if (envchanged)
 				*envchanged = 1;
 		} else if (!strcmp(cmd, "--bare")) {
-			static char git_dir[PATH_MAX+1];
+			static char git_dir[GIT_MAX_PATH+1];
 			is_bare_repository_cfg = 1;
 			setenv(GIT_DIR_ENVIRONMENT, getcwd(git_dir, sizeof(git_dir)), 0);
 			setenv(GIT_IMPLICIT_WORK_TREE_ENVIRONMENT, "0", 1);
diff --git a/gpg-interface.c b/gpg-interface.c
index 8b0e874..c03237d 100644
--- a/gpg-interface.c
+++ b/gpg-interface.c
@@ -104,13 +104,13 @@ int verify_signed_buffer(const char *payload, size_t payload_size,
 {
 	struct child_process gpg;
 	const char *args_gpg[] = {NULL, "--status-fd=1", "--verify", "FILE", "-", NULL};
-	char path[PATH_MAX];
+	char path[GIT_MAX_PATH];
 	int fd, ret;
 	struct strbuf buf = STRBUF_INIT;
 	struct strbuf *pbuf = &buf;
 
 	args_gpg[0] = gpg_program;
-	fd = git_mkstemp(path, PATH_MAX, ".git_vtag_tmpXXXXXX");
+	fd = git_mkstemp(path, GIT_MAX_PATH, ".git_vtag_tmpXXXXXX");
 	if (fd < 0)
 		return error(_("could not create temporary file '%s': %s"),
 			     path, strerror(errno));
diff --git a/http.c b/http.c
index b8444de..ef2fd52 100644
--- a/http.c
+++ b/http.c
@@ -1252,7 +1252,7 @@ struct http_object_request *new_http_object_request(const char *base_url,
 {
 	char *hex = sha1_to_hex(sha1);
 	char *filename;
-	char prevfile[PATH_MAX];
+	char prevfile[GIT_MAX_PATH];
 	int prevlocal;
 	char prev_buf[PREV_BUF_SIZE];
 	ssize_t prev_read = 0;
diff --git a/http.h b/http.h
index d77c1b5..6583665 100644
--- a/http.h
+++ b/http.h
@@ -155,7 +155,7 @@ struct http_pack_request {
 	struct packed_git *target;
 	struct packed_git **lst;
 	FILE *packfile;
-	char tmpfile[PATH_MAX];
+	char tmpfile[GIT_MAX_PATH];
 	struct curl_slist *range_header;
 	struct active_request_slot *slot;
 };
@@ -168,7 +168,7 @@ extern void release_http_pack_request(struct http_pack_request *preq);
 /* Helpers for fetching object */
 struct http_object_request {
 	char *url;
-	char tmpfile[PATH_MAX];
+	char tmpfile[GIT_MAX_PATH];
 	int localfile;
 	CURLcode curl_result;
 	char errorstr[CURL_ERROR_SIZE];
diff --git a/list-objects.c b/list-objects.c
index 3dd4a96..7971953 100644
--- a/list-objects.c
+++ b/list-objects.c
@@ -174,7 +174,7 @@ void traverse_commit_list(struct rev_info *revs,
 	struct commit *commit;
 	struct strbuf base;
 
-	strbuf_init(&base, PATH_MAX);
+	strbuf_init(&base, GIT_MAX_PATH);
 	while ((commit = get_revision(revs)) != NULL) {
 		/*
 		 * an uninteresting boundary commit may not have its tree
diff --git a/lockfile.c b/lockfile.c
index c6fb77b..4e37646 100644
--- a/lockfile.c
+++ b/lockfile.c
@@ -82,7 +82,7 @@ static char *resolve_symlink(char *p, size_t s)
 	int depth = MAXDEPTH;
 
 	while (depth--) {
-		char link[PATH_MAX];
+		char link[GIT_MAX_PATH];
 		int link_len = readlink(p, link, sizeof(link));
 		if (link_len < 0) {
 			/* not a symlink anymore */
@@ -229,7 +229,7 @@ int close_lock_file(struct lock_file *lk)
 
 int commit_lock_file(struct lock_file *lk)
 {
-	char result_file[PATH_MAX];
+	char result_file[GIT_MAX_PATH];
 	size_t i;
 	if (lk->fd >= 0 && close_lock_file(lk))
 		return -1;
diff --git a/notes.c b/notes.c
index f63fd57..e6a0438 100644
--- a/notes.c
+++ b/notes.c
@@ -482,7 +482,7 @@ handle_non_note:
 		 * component.
 		 */
 		{
-			char non_note_path[PATH_MAX];
+			char non_note_path[GIT_MAX_PATH];
 			char *p = non_note_path;
 			const char *q = sha1_to_hex(subtree->key_sha1);
 			int i;
diff --git a/pack-write.c b/pack-write.c
index ca9e63b..c0afe90 100644
--- a/pack-write.c
+++ b/pack-write.c
@@ -73,7 +73,7 @@ const char *write_idx_file(const char *index_name, struct pack_idx_entry **objec
 		f = sha1fd_check(index_name);
 	} else {
 		if (!index_name) {
-			static char tmp_file[PATH_MAX];
+			static char tmp_file[GIT_MAX_PATH];
 			fd = odb_mkstemp(tmp_file, sizeof(tmp_file), "pack/tmp_idx_XXXXXX");
 			index_name = xstrdup(tmp_file);
 		} else {
@@ -297,7 +297,7 @@ char *index_pack_lockfile(int ip_out)
 	 */
 	if (read_in_full(ip_out, packname, 46) == 46 && packname[45] == '\n' &&
 	    memcmp(packname, "keep\t", 5) == 0) {
-		char path[PATH_MAX];
+		char path[GIT_MAX_PATH];
 		packname[45] = 0;
 		snprintf(path, sizeof(path), "%s/pack/pack-%s.keep",
 			 get_object_directory(), packname + 5);
@@ -335,7 +335,7 @@ int encode_in_pack_object_header(enum object_type type, uintmax_t size, unsigned
 
 struct sha1file *create_tmp_packfile(char **pack_tmp_name)
 {
-	char tmpname[PATH_MAX];
+	char tmpname[GIT_MAX_PATH];
 	int fd;
 
 	fd = odb_mkstemp(tmpname, sizeof(tmpname), "pack/tmp_pack_XXXXXX");
diff --git a/path.c b/path.c
index 95cd7ae..5448fed 100644
--- a/path.c
+++ b/path.c
@@ -25,7 +25,7 @@ static char bad_path[] = "/bad-path/";
 
 static char *get_pathname(void)
 {
-	static char pathname_array[4][PATH_MAX];
+	static char pathname_array[4][GIT_MAX_PATH];
 	static int index;
 	return pathname_array[3 & ++index];
 }
@@ -88,7 +88,7 @@ char *git_snpath(char *buf, size_t n, const char *fmt, ...)
 
 char *git_pathdup(const char *fmt, ...)
 {
-	char path[PATH_MAX], *ret;
+	char path[GIT_MAX_PATH], *ret;
 	va_list args;
 	va_start(args, fmt);
 	ret = vsnpath(path, sizeof(path), fmt, args);
@@ -118,9 +118,9 @@ char *mkpath(const char *fmt, ...)
 	char *pathname = get_pathname();
 
 	va_start(args, fmt);
-	len = vsnprintf(pathname, PATH_MAX, fmt, args);
+	len = vsnprintf(pathname, GIT_MAX_PATH, fmt, args);
 	va_end(args);
-	if (len >= PATH_MAX)
+	if (len >= GIT_MAX_PATH)
 		return bad_path;
 	return cleanup_path(pathname);
 }
@@ -132,7 +132,7 @@ char *git_path(const char *fmt, ...)
 	char *ret;
 
 	va_start(args, fmt);
-	ret = vsnpath(pathname, PATH_MAX, fmt, args);
+	ret = vsnpath(pathname, GIT_MAX_PATH, fmt, args);
 	va_end(args);
 	return ret;
 }
@@ -172,7 +172,7 @@ char *git_path_submodule(const char *path, const char *fmt, ...)
 	unsigned len;
 
 	len = strlen(path);
-	if (len > PATH_MAX-100)
+	if (len > GIT_MAX_PATH-100)
 		return bad_path;
 
 	strbuf_addstr(&buf, path);
@@ -187,7 +187,7 @@ char *git_path_submodule(const char *path, const char *fmt, ...)
 	}
 	strbuf_addch(&buf, '/');
 
-	if (buf.len >= PATH_MAX)
+	if (buf.len >= GIT_MAX_PATH)
 		return bad_path;
 	memcpy(pathname, buf.buf, buf.len + 1);
 
@@ -195,9 +195,9 @@ char *git_path_submodule(const char *path, const char *fmt, ...)
 	len = strlen(pathname);
 
 	va_start(args, fmt);
-	len += vsnprintf(pathname + len, PATH_MAX - len, fmt, args);
+	len += vsnprintf(pathname + len, GIT_MAX_PATH - len, fmt, args);
 	va_end(args);
-	if (len >= PATH_MAX)
+	if (len >= GIT_MAX_PATH)
 		return bad_path;
 	return cleanup_path(pathname);
 }
@@ -326,8 +326,8 @@ return_null:
  */
 const char *enter_repo(const char *path, int strict)
 {
-	static char used_path[PATH_MAX];
-	static char validated_path[PATH_MAX];
+	static char used_path[GIT_MAX_PATH];
+	static char validated_path[GIT_MAX_PATH];
 
 	if (!path)
 		return NULL;
@@ -342,26 +342,26 @@ const char *enter_repo(const char *path, int strict)
 		while ((1 < len) && (path[len-1] == '/'))
 			len--;
 
-		if (PATH_MAX <= len)
+		if (GIT_MAX_PATH <= len)
 			return NULL;
 		strncpy(used_path, path, len); used_path[len] = 0 ;
 		strcpy(validated_path, used_path);
 
 		if (used_path[0] == '~') {
 			char *newpath = expand_user_path(used_path);
-			if (!newpath || (PATH_MAX - 10 < strlen(newpath))) {
+			if (!newpath || (GIT_MAX_PATH - 10 < strlen(newpath))) {
 				free(newpath);
 				return NULL;
 			}
 			/*
 			 * Copy back into the static buffer. A pity
 			 * since newpath was not bounded, but other
-			 * branches of the if are limited by PATH_MAX
+			 * branches of the if are limited by GIT_MAX_PATH
 			 * anyway.
 			 */
 			strcpy(used_path, newpath); free(newpath);
 		}
-		else if (PATH_MAX - 10 < len)
+		else if (GIT_MAX_PATH - 10 < len)
 			return NULL;
 		len = strlen(used_path);
 		for (i = 0; suffix[i]; i++) {
@@ -443,7 +443,7 @@ int adjust_shared_perm(const char *path)
 
 const char *relative_path(const char *abs, const char *base)
 {
-	static char buf[PATH_MAX + 1];
+	static char buf[GIT_MAX_PATH + 1];
 	int i = 0, j = 0;
 
 	if (!base || !base[0])
diff --git a/refs.c b/refs.c
index de2d8eb..20fd9aa 100644
--- a/refs.c
+++ b/refs.c
@@ -833,7 +833,7 @@ static const char *parse_ref_line(char *line, unsigned char *sha1)
 static void read_packed_refs(FILE *f, struct ref_dir *dir)
 {
 	struct ref_entry *last = NULL;
-	char refline[PATH_MAX];
+	char refline[GIT_MAX_PATH];
 	enum { PEELED_NONE, PEELED_TAGS, PEELED_FULLY } peeled = PEELED_NONE;
 
 	while (fgets(refline, sizeof(refline), f)) {
@@ -1097,7 +1097,7 @@ const char *resolve_ref_unsafe(const char *refname, unsigned char *sha1, int rea
 		return NULL;
 
 	for (;;) {
-		char path[PATH_MAX];
+		char path[GIT_MAX_PATH];
 		struct stat st;
 		char *buf;
 		int fd;
@@ -1597,7 +1597,7 @@ int dwim_ref(const char *str, int len, unsigned char *sha1, char **ref)
 
 	*ref = NULL;
 	for (p = ref_rev_parse_rules; *p; p++) {
-		char fullref[PATH_MAX];
+		char fullref[GIT_MAX_PATH];
 		unsigned char sha1_from_ref[20];
 		unsigned char *this_result;
 		int flag;
@@ -1630,7 +1630,7 @@ int dwim_log(const char *str, int len, unsigned char *sha1, char **log)
 	for (p = ref_rev_parse_rules; *p; p++) {
 		struct stat st;
 		unsigned char hash[20];
-		char path[PATH_MAX];
+		char path[GIT_MAX_PATH];
 		const char *ref, *it;
 
 		mksnpath(path, sizeof(path), *p, len, str);
@@ -1739,7 +1739,7 @@ static struct ref_lock *lock_ref_sha1_basic(const char *refname,
 
 struct ref_lock *lock_ref_sha1(const char *refname, const unsigned char *old_sha1)
 {
-	char refpath[PATH_MAX];
+	char refpath[GIT_MAX_PATH];
 	if (check_refname_format(refname, 0))
 		return NULL;
 	strcpy(refpath, mkpath("refs/%s", refname));
@@ -1763,7 +1763,7 @@ static int repack_without_ref_fn(const char *refname, const unsigned char *sha1,
 				 int flags, void *cb_data)
 {
 	struct repack_without_ref_sb *data = cb_data;
-	char line[PATH_MAX + 100];
+	char line[GIT_MAX_PATH + 100];
 	int len;
 
 	if (!strcmp(data->refname, refname))
@@ -2048,7 +2048,7 @@ static int log_ref_write(const char *refname, const unsigned char *old_sha1,
 	int logfd, result, written, oflags = O_APPEND | O_WRONLY;
 	unsigned maxlen, len;
 	int msglen;
-	char log_file[PATH_MAX];
+	char log_file[GIT_MAX_PATH];
 	char *logrec;
 	const char *committer;
 
@@ -2513,7 +2513,7 @@ int for_each_reflog(each_ref_fn fn, void *cb_data)
 {
 	int retval;
 	struct strbuf name;
-	strbuf_init(&name, PATH_MAX);
+	strbuf_init(&name, GIT_MAX_PATH);
 	retval = do_for_each_reflog(&name, fn, cb_data);
 	strbuf_release(&name);
 	return retval;
@@ -2635,7 +2635,7 @@ char *shorten_unambiguous_ref(const char *refname, int strict)
 		 */
 		for (j = 0; j < rules_to_fail; j++) {
 			const char *rule = ref_rev_parse_rules[j];
-			char refname[PATH_MAX];
+			char refname[GIT_MAX_PATH];
 
 			/* skip matched rule */
 			if (i == j)
diff --git a/rerere.c b/rerere.c
index 98e3e29..9f430ae 100644
--- a/rerere.c
+++ b/rerere.c
@@ -34,7 +34,7 @@ static int has_rerere_resolution(const char *hex)
 static void read_rr(struct string_list *rr)
 {
 	unsigned char sha1[20];
-	char buf[PATH_MAX];
+	char buf[GIT_MAX_PATH];
 	FILE *in = fopen(merge_rr_path, "r");
 	if (!in)
 		return;
diff --git a/run-command.c b/run-command.c
index 2a12ef2..a017118 100644
--- a/run-command.c
+++ b/run-command.c
@@ -759,7 +759,7 @@ int run_hook(const char *index_file, const char *name, ...)
 	struct child_process hook;
 	struct argv_array argv = ARGV_ARRAY_INIT;
 	const char *p, *env[2];
-	char index[PATH_MAX];
+	char index[GIT_MAX_PATH];
 	va_list args;
 	int ret;
 
diff --git a/server-info.c b/server-info.c
index 9ec744e..1f07609 100644
--- a/server-info.c
+++ b/server-info.c
@@ -208,8 +208,8 @@ static void write_pack_info_file(FILE *fp)
 
 static int update_info_packs(int force)
 {
-	char infofile[PATH_MAX];
-	char name[PATH_MAX];
+	char infofile[GIT_MAX_PATH];
+	char name[GIT_MAX_PATH];
 	int namelen;
 	FILE *fp;
 
diff --git a/setup.c b/setup.c
index 94c1e61..a9d26fe 100644
--- a/setup.c
+++ b/setup.c
@@ -317,10 +317,10 @@ const char **get_pathspec(const char *prefix, const char **pathspec)
  */
 int is_git_directory(const char *suspect)
 {
-	char path[PATH_MAX];
+	char path[GIT_MAX_PATH];
 	size_t len = strlen(suspect);
 
-	if (PATH_MAX <= len + strlen("/objects"))
+	if (GIT_MAX_PATH <= len + strlen("/objects"))
 		die("Too long path: %.*s", 60, suspect);
 	strcpy(path, suspect);
 	if (getenv(DB_ENVIRONMENT)) {
@@ -385,7 +385,7 @@ void setup_work_tree(void)
 
 static int check_repository_format_gently(const char *gitdir, int *nongit_ok)
 {
-	char repo_config[PATH_MAX+1];
+	char repo_config[GIT_MAX_PATH+1];
 
 	/*
 	 * git_config() can't be used here because it calls git_pathdup()
@@ -396,7 +396,7 @@ static int check_repository_format_gently(const char *gitdir, int *nongit_ok)
 	 * Use a gentler version of git_config() to check if this repo
 	 * is a good one.
 	 */
-	snprintf(repo_config, PATH_MAX, "%s/config", gitdir);
+	snprintf(repo_config, GIT_MAX_PATH, "%s/config", gitdir);
 	git_config_early(check_repository_format_version, NULL, repo_config);
 	if (GIT_REPO_VERSION < repository_format_version) {
 		if (!nongit_ok)
@@ -474,7 +474,7 @@ static const char *setup_explicit_git_dir(const char *gitdirenv,
 	char *gitfile;
 	int offset;
 
-	if (PATH_MAX - 40 < strlen(gitdirenv))
+	if (GIT_MAX_PATH - 40 < strlen(gitdirenv))
 		die("'$%s' too big", GIT_DIR_ENVIRONMENT);
 
 	gitfile = (char*)read_gitfile(gitdirenv);
@@ -513,12 +513,12 @@ static const char *setup_explicit_git_dir(const char *gitdirenv,
 		if (is_absolute_path(git_work_tree_cfg))
 			set_git_work_tree(git_work_tree_cfg);
 		else {
-			char core_worktree[PATH_MAX];
+			char core_worktree[GIT_MAX_PATH];
 			if (chdir(gitdirenv))
 				die_errno("Could not chdir to '%s'", gitdirenv);
 			if (chdir(git_work_tree_cfg))
 				die_errno("Could not chdir to '%s'", git_work_tree_cfg);
-			if (!getcwd(core_worktree, PATH_MAX))
+			if (!getcwd(core_worktree, GIT_MAX_PATH))
 				die_errno("Could not get directory '%s'", git_work_tree_cfg);
 			if (chdir(cwd))
 				die_errno("Could not come back to cwd");
@@ -696,7 +696,7 @@ static const char *setup_git_directory_gently_1(int *nongit_ok)
 {
 	const char *env_ceiling_dirs = getenv(CEILING_DIRECTORIES_ENVIRONMENT);
 	struct string_list ceiling_dirs = STRING_LIST_INIT_DUP;
-	static char cwd[PATH_MAX+1];
+	static char cwd[GIT_MAX_PATH+1];
 	const char *gitdirenv, *ret;
 	char *gitfile;
 	int len, offset, offset_parent, ceil_offset = -1;
diff --git a/sha1_file.c b/sha1_file.c
index 67e815b..9ed8c4f 100644
--- a/sha1_file.c
+++ b/sha1_file.c
@@ -174,7 +174,7 @@ static void fill_sha1_path(char *pathbuf, const unsigned char *sha1)
  */
 char *sha1_file_name(const unsigned char *sha1)
 {
-	static char buf[PATH_MAX];
+	static char buf[GIT_MAX_PATH];
 	const char *objdir;
 	int len;
 
@@ -182,7 +182,7 @@ char *sha1_file_name(const unsigned char *sha1)
 	len = strlen(objdir);
 
 	/* '/' + sha1(2) + '/' + sha1(38) + '\0' */
-	if (len + 43 > PATH_MAX)
+	if (len + 43 > GIT_MAX_PATH)
 		die("insanely long object directory %s", objdir);
 	memcpy(buf, objdir, len);
 	buf[len] = '/';
@@ -359,10 +359,10 @@ void read_info_alternates(const char * relative_base, int depth)
 	size_t mapsz;
 	struct stat st;
 	const char alt_file_name[] = "info/alternates";
-	/* Given that relative_base is no longer than PATH_MAX,
+	/* Given that relative_base is no longer than GIT_MAX_PATH,
 	   ensure that "path" has enough space to append "/", the
 	   file name, "info/alternates", and a trailing NUL.  */
-	char path[PATH_MAX + 1 + sizeof alt_file_name];
+	char path[GIT_MAX_PATH + 1 + sizeof alt_file_name];
 	int fd;
 
 	sprintf(path, "%s/%s", relative_base, alt_file_name);
@@ -1067,8 +1067,8 @@ static void prepare_packed_git_one(char *objdir, int local)
 {
 	/* Ensure that this buffer is large enough so that we can
 	   append "/pack/" without clobbering the stack even if
-	   strlen(objdir) were PATH_MAX.  */
-	char path[PATH_MAX + 1 + 4 + 1 + 1];
+	   strlen(objdir) were GIT_MAX_PATH.  */
+	char path[GIT_MAX_PATH + 1 + 4 + 1 + 1];
 	int len;
 	DIR *dir;
 	struct dirent *de;
@@ -2716,7 +2716,7 @@ static int write_loose_object(const unsigned char *sha1, char *hdr, int hdrlen,
 	git_SHA_CTX c;
 	unsigned char parano_sha1[20];
 	char *filename;
-	static char tmp_file[PATH_MAX];
+	static char tmp_file[GIT_MAX_PATH];
 
 	filename = sha1_file_name(sha1);
 	fd = create_tmpfile(tmp_file, sizeof(tmp_file), filename);
diff --git a/strbuf.c b/strbuf.c
index 1170d01..a77492f 100644
--- a/strbuf.c
+++ b/strbuf.c
@@ -368,7 +368,7 @@ ssize_t strbuf_read(struct strbuf *sb, int fd, size_t hint)
 	return sb->len - oldlen;
 }
 
-#define STRBUF_MAXLINK (2*PATH_MAX)
+#define STRBUF_MAXLINK (2*GIT_MAX_PATH)
 
 int strbuf_readlink(struct strbuf *sb, const char *path, size_t hint)
 {
diff --git a/symlinks.c b/symlinks.c
index c2b41a8..ca06190 100644
--- a/symlinks.c
+++ b/symlinks.c
@@ -121,7 +121,7 @@ static int lstat_cache_matchlen(struct cache_def *cache,
 	 */
 	*ret_flags = FL_DIR;
 	last_slash_dir = last_slash;
-	max_len = len < PATH_MAX ? len : PATH_MAX;
+	max_len = len < GIT_MAX_PATH ? len : GIT_MAX_PATH;
 	while (match_len < max_len) {
 		do {
 			cache->path[match_len] = name[match_len];
@@ -158,12 +158,12 @@ static int lstat_cache_matchlen(struct cache_def *cache,
 	 * for the moment!
 	 */
 	save_flags = *ret_flags & track_flags & (FL_NOENT|FL_SYMLINK);
-	if (save_flags && last_slash > 0 && last_slash <= PATH_MAX) {
+	if (save_flags && last_slash > 0 && last_slash <= GIT_MAX_PATH) {
 		cache->path[last_slash] = '\0';
 		cache->len = last_slash;
 		cache->flags = save_flags;
 	} else if ((track_flags & FL_DIR) &&
-		   last_slash_dir > 0 && last_slash_dir <= PATH_MAX) {
+		   last_slash_dir > 0 && last_slash_dir <= GIT_MAX_PATH) {
 		/*
 		 * We have a separate test for the directory case,
 		 * since it could be that we have found a symlink or a
@@ -274,7 +274,7 @@ static int threaded_has_dirs_only_path(struct cache_def *cache, const char *name
 }
 
 static struct removal_def {
-	char path[PATH_MAX];
+	char path[GIT_MAX_PATH];
 	int len;
 } removal;
 
diff --git a/test-dump-cache-tree.c b/test-dump-cache-tree.c
index a6ffdf3..1fd7512 100644
--- a/test-dump-cache-tree.c
+++ b/test-dump-cache-tree.c
@@ -42,7 +42,7 @@ static int dump_cache_tree(struct cache_tree *it,
 	}
 
 	for (i = 0; i < it->subtree_nr; i++) {
-		char path[PATH_MAX];
+		char path[GIT_MAX_PATH];
 		struct cache_tree_sub *down = it->down[i];
 		struct cache_tree_sub *rdwn;
 
diff --git a/test-path-utils.c b/test-path-utils.c
index 0092cbf..b616a12 100644
--- a/test-path-utils.c
+++ b/test-path-utils.c
@@ -10,11 +10,11 @@ static int normalize_ceiling_entry(struct string_list_item *item, void *unused)
 {
 	const char *ceil = item->string;
 	int len = strlen(ceil);
-	char buf[PATH_MAX+1];
+	char buf[GIT_MAX_PATH+1];
 
 	if (len == 0)
 		die("Empty path is not supported");
-	if (len > PATH_MAX)
+	if (len > GIT_MAX_PATH)
 		die("Path \"%s\" is too long", ceil);
 	if (!is_absolute_path(ceil))
 		die("Path \"%s\" is not absolute", ceil);
@@ -31,7 +31,7 @@ static int normalize_ceiling_entry(struct string_list_item *item, void *unused)
 int main(int argc, char **argv)
 {
 	if (argc == 3 && !strcmp(argv[1], "normalize_path_copy")) {
-		char *buf = xmalloc(PATH_MAX + 1);
+		char *buf = xmalloc(GIT_MAX_PATH + 1);
 		int rv = normalize_path_copy(buf, argv[2]);
 		if (rv)
 			buf = "++failed++";
diff --git a/trace.c b/trace.c
index 5ec0e3b..a67cd4f 100644
--- a/trace.c
+++ b/trace.c
@@ -131,7 +131,7 @@ void trace_argv_printf(const char **argv, const char *fmt, ...)
 
 static const char *quote_crnl(const char *path)
 {
-	static char new_path[PATH_MAX];
+	static char new_path[GIT_MAX_PATH];
 	const char *p2 = path;
 	char *p1 = new_path;
 
@@ -157,12 +157,12 @@ void trace_repo_setup(const char *prefix)
 {
 	static const char *key = "GIT_TRACE_SETUP";
 	const char *git_work_tree;
-	char cwd[PATH_MAX];
+	char cwd[GIT_MAX_PATH];
 
 	if (!trace_want(key))
 		return;
 
-	if (!getcwd(cwd, PATH_MAX))
+	if (!getcwd(cwd, GIT_MAX_PATH))
 		die("Unable to get current working directory");
 
 	if (!(git_work_tree = get_git_work_tree()))
diff --git a/transport-helper.c b/transport-helper.c
index e6e1f74..56969cb 100644
--- a/transport-helper.c
+++ b/transport-helper.c
@@ -114,7 +114,7 @@ static struct child_process *get_helper(struct transport *transport)
 	int refspec_alloc = 0;
 	int duped;
 	int code;
-	char git_dir_buf[sizeof(GIT_DIR_ENVIRONMENT) + PATH_MAX + 1];
+	char git_dir_buf[sizeof(GIT_DIR_ENVIRONMENT) + GIT_MAX_PATH + 1];
 	const char *helper_env[] = {
 		git_dir_buf,
 		NULL
diff --git a/transport.c b/transport.c
index ba5d8af..b8297bd 100644
--- a/transport.c
+++ b/transport.c
@@ -100,7 +100,7 @@ static int read_loose_refs(struct strbuf *path, int name_offset,
 static void insert_packed_refs(const char *packed_refs, struct ref **list)
 {
 	FILE *f = fopen(packed_refs, "r");
-	static char buffer[PATH_MAX];
+	static char buffer[GIT_MAX_PATH];
 
 	if (!f)
 		return;
diff --git a/tree-diff.c b/tree-diff.c
index ba01563..dd5710e 100644
--- a/tree-diff.c
+++ b/tree-diff.c
@@ -140,7 +140,7 @@ int diff_tree(struct tree_desc *t1, struct tree_desc *t2,
 	opt->pathspec.recursive = DIFF_OPT_TST(opt, RECURSIVE);
 	opt->pathspec.max_depth = -1;
 
-	strbuf_init(&base, PATH_MAX);
+	strbuf_init(&base, GIT_MAX_PATH);
 	strbuf_add(&base, base_str, baselen);
 
 	for (;;) {
diff --git a/unix-socket.c b/unix-socket.c
index 01f119f..86b3a71 100644
--- a/unix-socket.c
+++ b/unix-socket.c
@@ -18,7 +18,7 @@ static int chdir_len(const char *orig, int len)
 }
 
 struct unix_sockaddr_context {
-	char orig_dir[PATH_MAX];
+	char orig_dir[GIT_MAX_PATH];
 };
 
 static void unix_sockaddr_cleanup(struct unix_sockaddr_context *ctx)
diff --git a/unpack-trees.c b/unpack-trees.c
index ede4299..d9dc310 100644
--- a/unpack-trees.c
+++ b/unpack-trees.c
@@ -955,7 +955,7 @@ static int clear_ce_flags(struct cache_entry **cache, int nr,
 			    int select_mask, int clear_mask,
 			    struct exclude_list *el)
 {
-	char prefix[PATH_MAX];
+	char prefix[GIT_MAX_PATH];
 	return clear_ce_flags_1(cache, nr,
 				prefix, 0,
 				select_mask, clear_mask,
@@ -1419,7 +1419,7 @@ static int verify_absent_1(struct cache_entry *ce,
 	if (!len)
 		return 0;
 	else if (len > 0) {
-		char path[PATH_MAX + 1];
+		char path[GIT_MAX_PATH + 1];
 		memcpy(path, ce->name, len);
 		path[len] = 0;
 		if (lstat(path, &st))
diff --git a/wrapper.c b/wrapper.c
index bac59d2..8eee846 100644
--- a/wrapper.c
+++ b/wrapper.c
@@ -221,7 +221,7 @@ FILE *xfdopen(int fd, const char *mode)
 int xmkstemp(char *template)
 {
 	int fd;
-	char origtemplate[PATH_MAX];
+	char origtemplate[GIT_MAX_PATH];
 	strlcpy(origtemplate, template, sizeof(origtemplate));
 
 	fd = mkstemp(template);
@@ -356,7 +356,7 @@ int gitmkstemps(char *pattern, int suffix_len)
 int xmkstemp_mode(char *template, int mode)
 {
 	int fd;
-	char origtemplate[PATH_MAX];
+	char origtemplate[GIT_MAX_PATH];
 	strlcpy(origtemplate, template, sizeof(origtemplate));
 
 	fd = git_mkstemp_mode(template, mode);
diff --git a/wt-status.c b/wt-status.c
index bf84a86..9be7f04 100644
--- a/wt-status.c
+++ b/wt-status.c
@@ -660,7 +660,7 @@ static void wt_status_print_submodule_summary(struct wt_status *s, int uncommitt
 {
 	struct child_process sm_summary;
 	char summary_limit[64];
-	char index[PATH_MAX];
+	char index[GIT_MAX_PATH];
 	const char *env[] = { NULL, NULL };
 	const char *argv[8];
 
